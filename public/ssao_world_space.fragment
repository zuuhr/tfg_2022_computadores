precision highp float;
        
varying vec2 vUV;
varying vec4 vPosition;

uniform sampler2D textureSampler;
uniform sampler2D normalTexture;
uniform sampler2D depthTexture;
uniform sampler2D noiseTexture;

uniform float radius;
uniform int numSamples;
uniform vec3 kernelSphere[16]; 
uniform float fallOff;
uniform float area;
uniform float bias;
uniform float near;
uniform float far;

uniform mat4 projection; 
uniform mat4 view; 

vec3 getRandomVec3(vec2 uv){
    return normalize( 
        vec3( texture2D(noiseTexture, uv).rg * 2.0 - 1.0,
        0.0) 
    );
}

vec3 viewSpaceToWorldSpace(vec3 v){
    return (inverse(view) * vec4(v, 1.0)).xyz;
}

vec3 clipSpaceToViewSpace(vec3 v){
    mat4 projectionIN = inverse(projection);
    vec4 v4 = (projectionIN * vec4(v, 1.0));
    v4.w = 1.0 / v4.w;
    v4.x *= v4.w;
    v4.y *= v4.w;
    v4.z *= v4.w;
    return v4.xyz;
}

void main(void){
    //Linear depth from texture
    // float depth = texture2D(depthTexture, vUV).r;
    //remap form  (0, 1) to (-1, 1)
    float depth = texture2D(depthTexture, vUV).r * 2.0 - 1.0;
    depth = -depth;
    //Clip Space Fragment Position (z scale in ss and vs don't vary) screen space (* 2.0 - 1.0) - > clip space
    vec3 fragPos = vec3(vUV * 2.0 - 1.0, depth);
    
    //World Space Fragment Position 
    vec3 WS_fragPos = clipSpaceToViewSpace(fragPos);
    //I think it works?
    WS_fragPos = viewSpaceToWorldSpace(WS_fragPos);
    // WS_fragPos /= 10.0;

    //World Space Normal
    vec3 fragN = normalize(texture2D(normalTexture, vUV).xyz);
    //Tangent Space randomVec
    vec3 randomVec = getRandomVec3(vUV); 
    // randomVec = vec3(1.0, 0.0, 0.0);
    //Generate kernelSphere rotated along surface normal -> use TBN matrix 
    vec3 tangent = normalize(randomVec - fragN * dot(randomVec, fragN));
    //gram schmidt:
    tangent = normalize(tangent - fragN * dot(tangent, fragN));
    vec3 binormal = cross(fragN, tangent);
    mat3 TBN = mat3(tangent, binormal, fragN);
    //The further the distance the bigger the radius in view space 
    float scale = radius / depth; 
    //fixed for testing reasons
    //TODO: tama√±o maximo
    // scale = radius;
    float ao = 0.0;
    float prueba = 0.0;
    vec3 pruebaVec = vec3(0.0, 0.0, 0.0);
    for(int i = 0; i < numSamples; i++){
        
        //Sample position in world space
        // vec3 samplePosition =  TBN * kernelSphere[i];
        // pruebaVec = -samplePosition;
        // samplePosition = normalize(samplePosition);

        //colocamos 
        vec3 test = TBN * WS_fragPos;
        vec3 samplePosition = test + TBN * kernelSphere[i];
        pruebaVec = test;

        // pruebaVec = TBN * vec3(1.0, 1.0, 1.0);
        //offset sample position with current fragment
        // samplePosition = WS_fragPos + samplePosition * scale;
        samplePosition = WS_fragPos + samplePosition * 0.000005;
        // pruebaVec = samplePosition;

        //samplePos depth in ??? Space
        // float sampleDepth = samplePosition.z; //Z aleatoria

        //world space -> (view) -> view space-> (projection) -> clip space-> (/ 2.0 + 0.5) -> screen space
        vec3 VS_samplePosition = (view * vec4(samplePosition, 1.0)).xyz;
        vec3 aaa = (view * vec4(WS_fragPos, 1.0)).xyz;
        //looks like it works 
        // pruebaVec = VS_samplePosition;
        // pruebaVec = aaa;
        
        vec2 sampleCoord = (projection * vec4(VS_samplePosition, 1.0)).xy / 2.0 + 0.5;
        //offset Depth is the real depth of the screen fragment at the same xy of samplePosition
        float offsetDepth = texture2D(depthTexture, sampleCoord).r * 2.0 - 1.0;
        //difference is comparison of the depth of the sample and the depth at that position 

        ////BEGIN [GAMEDEV CODE]
        ////comprobar si la superficie ocluye hacia el fragmento 
        vec3 CS_offsetPos = vec3(sampleCoord, offsetDepth);
        vec3 VS_offsetPos = clipSpaceToViewSpace(CS_offsetPos);
        vec3 WS_offsetPos = viewSpaceToWorldSpace(VS_offsetPos);

        vec3 diff = WS_offsetPos - WS_fragPos;
        diff = -diff;
        vec3 v = normalize(diff);
        float d = length(diff) * scale;
        d = length(diff);
        // ao += max(0.0, dot(fragN, v) - bias) * (1.0 / (1.0 + d));
        // float rangeCheck =  1.0 / (1.0 + d * 200.0);
        float rangeCheck =  1.0 / (1.0 + d);
        // ao += max(0.0, dot(fragN, v) ) * rangeCheck - bias;
        ao += max(0.0, dot(fragN, v) );
        ////END [GAMEDEV CODE]


        // prueba = max(0.0, dot(fragN, v) - bias);
        // prueba =  dot(fragN, v);
        // pruebaVec = samplePosition;

        // pruebaVec = v * 0.5 + 0.5;
        // if(i == numSamples - 4){
        //     pruebaVec = VS_offsetPos;
        // }
    }
    // prueba /= float(numSamples);
    ao /= float(numSamples);
    // ao *= 500.0;
    // ao = 1.0 - sao;
    // pruebaVec = WS_fragPos;
    
    // gl_FragColor = vec4(depth, depth, depth, 1);
    // gl_FragColor = texture2D(noiseTexture, vUV);
    // gl_FragColor = vec4(tangent, 1);
    // gl_FragColor = vec4(binormal, 1);
    // gl_FragColor = vec4(fragN, 1);
    // gl_FragColor = texture2D(textureSampler, vUV);
    // gl_FragColor = vec4(ao, ao, ao, 1);
    gl_FragColor = vec4(pruebaVec, 1);
    // gl_FragColor = vec4(prueba, prueba, prueba, 1);
}