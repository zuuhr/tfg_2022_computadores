precision highp float;
        
varying vec2 vUV;
varying vec4 vPosition;

uniform sampler2D textureSampler;
uniform sampler2D normalTexture;
uniform sampler2D depthTexture;
uniform sampler2D noiseTexture;
uniform sampler2D positionTexture;

uniform float radius;
uniform int numSamples;
uniform vec2 kernelSphere[16]; 
uniform float fallOff;
uniform float area;
uniform float bias;
uniform float near;
uniform float far;

uniform mat4 projection; 
uniform mat4 view;

vec2 vec[8];

vec3 VSPositionFromDepth(vec2 texCoord)
{
    // Get the depth value for this pixel
    float z = texture2D(depthTexture, texCoord).r;
    // Get x/w and y/w from the viewport position
    float x = texCoord.x * 2.0 - 1.0;
    float y = texCoord.y * 2.0 - 1.0;
    vec4 projectedPos = vec4(x, y, z, 1.0);
    // Transform by the inverse projection matrix
    mat4 projectionIN = inverse(projection);
    vec4 positionVS = projectionIN * projectedPos;
    // Divide by w to get the view-space position
    vec3 a = positionVS.xyz / positionVS.w;  
    return a.xyz;
}

void main(void){

    vec[0] = vec2(1,0);
    vec[1] = vec2(-1,0);
    vec[2] = vec2(0,1);
    vec[3] = vec2(0,-1);
    vec[4] = vec2(1,1);
    vec[5] = vec2(-1,1);
    vec[6] = vec2(-1,-1);
    vec[7] = vec2(1,-1);

    vec3 VS_fragPos = VSPositionFromDepth(vUV);

    // View Space Normal DONT NORMALIZE
    vec3 fragN = texture2D(normalTexture, vUV).xyz;
    fragN = fragN * 2.0 - 1.0;

    //The further the distance the bigger the radius in view space 
    float scale = 0.001 / VS_fragPos.z; 

    float ao = 0.0;

    float prueba = 0.0;
    vec3 pruebaVec = vec3(0.0, 0.0, 0.0);
    float temp = 0.0;

    for(int i = 0; i < 8; i++){
        vec2 sampleCoord = vec[i].xy * scale;
        vec3 VS_offsetPos = VSPositionFromDepth(vUV + sampleCoord);

        vec3 diff = VS_offsetPos - VS_fragPos;
        float offsetNAngle = dot(fragN, normalize(diff));
        // temp += offsetNAngle;
        ao += -offsetNAngle;
        
    }

    // temp /= float(numSamples);
    // prueba = temp;
    if(ao > 0.0){
        ao /= float(numSamples);
    } else {
        ao = 0.0;
    }
    ao = 1.0 - ao;
    gl_FragColor = vec4(ao, ao, ao, 1);
    // gl_FragColor = vec4(fragN, 1);
    // gl_FragColor = vec4(prueba, -prueba, 0.0, 1);
}